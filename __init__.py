from __future__ import annotations
import requests
from tqdm import tqdm
import shutil
import re
import os

from comfy_api.latest import ComfyExtension, io
import folder_paths
import comfy.utils
import logging
from server import PromptServer
import comfy.model_management



folder_names_and_paths_list = list(folder_paths.folder_names_and_paths.keys())


def to_valid_filename(s: str, replacement: str = "_", max_length: int = 255) -> str:
    """
    This was generated by ChatGPT.
    Convert a string into a valid filename by replacing invalid characters
    and trimming to the max allowed length.
    
    Args:
        s (str): Input string
        replacement (str): Character to replace invalid chars with (default "_")
        max_length (int): Maximum allowed length (default 255, common on most filesystems)
    
    Returns:
        str: Sanitized filename
    """
    # Replace invalid characters (Windows reserved + control chars)
    s = re.sub(r'[<>:"/\\|?*\x00-\x1F]', replacement, s)

    # Remove trailing spaces and dots (invalid on Windows)
    s = s.rstrip(" .")

    # Ensure non-empty
    if not s:
        return s

    # Trim if necessary
    if len(s) > max_length:
        # Try to preserve extension if it exists
        name, ext = os.path.splitext(s)
        keep_length = max_length - len(ext)
        s = name[:keep_length].rstrip(" .") + ext

    return s

def _validate_file_extension(file_name):
    """Validate that the file extension is supported."""
    extension = os.path.splitext(file_name)[1]
    if extension not in (".safetensors", ".sft", ".txt", ".csv", ".json", ".yaml"):
        raise ValueError(f"Unsupported unsafe file for download: {file_name}")

def _download_file(url, destination_path, hidden: io.HiddenHolder):
    """Download a file."""
    response = requests.get(url, stream=True)
    logging.info(f"Downloading {url} to {destination_path}")
    display_modulus = 200

    

    with open(destination_path, "wb") as f:
        total_size = int(response.headers.get("content-length", 0))
        if total_size > 0:
            pbar = comfy.utils.ProgressBar(total_size)
        else:
            pbar = None
        display_text = f"Downloading {total_size/(1000*1000*1000):.2f} GB from {url} to {destination_path}"
        PromptServer.instance.send_progress_text(display_text, hidden.unique_id)
        with tqdm(total=total_size, unit="B", unit_scale=True) as progress_bar:
            chunk_count = 0
            total_downloaded = 0
            for chunk in response.iter_content(chunk_size=128 * 1024):
                comfy.model_management.throw_exception_if_processing_interrupted()
                if chunk:
                    f.write(chunk)
                    len_chunk = len(chunk)
                    total_downloaded += len_chunk
                    progress_bar.update(len_chunk)
                    if pbar and chunk_count % display_modulus == 0:
                        pbar.update_absolute(total_downloaded, total_size)
                    chunk_count += 1

class DownloadWhatIWantNode(io.ComfyNode):
    @classmethod
    def define_schema(cls):
        return io.Schema(
            node_id="DownloadWhatIWant",
            display_name="DownloadWhatIWant",
            description="Download what I want.",
            inputs=[
                io.String.Input("url", tooltip="The URL of the file to download."),
                io.String.Input("name_override", tooltip="What to call the name after downloading."),
                io.Combo.Input("folder_name", tooltip="The folder to download the file to.", options=folder_names_and_paths_list),
            ],
            hidden=[
                io.Hidden.unique_id
            ],
            is_output_node=True,
        )
    
    @classmethod
    def execute(cls, url: str, name_override: str, folder_name: str):
        name_override = to_valid_filename(name_override.strip())
        matching_folder_paths = folder_paths.get_folder_paths(folder_name)
        first_folder_path = matching_folder_paths[0]
        for folder_path in matching_folder_paths:
            if folder_name in folder_path:
                first_folder_path = folder_path
                break
        filename = url.strip().split("/")[-1]
        extension = filename.split(".")[-1]
        if extension == "":
            extension = "safetensors"
        if name_override != "":
            if '.' not in name_override:
                filename = name_override + "." + extension
            else:
                filename = name_override
        else:
            filename = f"{filename}"
        _validate_file_extension(filename)
        destination_path = os.path.join(first_folder_path, filename)
        temp_dir = os.path.join(folder_paths.get_temp_directory(), "download_what_i_want")
        os.makedirs(temp_dir, exist_ok=True)
        temp_path = os.path.join(temp_dir, filename)
        _download_file(url, temp_path, cls.hidden)
        logging.info(f"Downloaded {url} to {temp_path}")
        logging.info(f"Moving {temp_path} to {destination_path}")
        PromptServer.instance.send_progress_text(f"Moving {temp_path} to {destination_path}", cls.hidden.unique_id)
        shutil.move(temp_path, destination_path)
        logging.info(f"Moved {temp_path} to {destination_path}")
        PromptServer.instance.send_progress_text(f"Downloaded {url} to {destination_path}", cls.hidden.unique_id)
        return io.NodeOutput()

class DownloadWhatIWantExtension(ComfyExtension):
    async def get_node_list(self) -> list[type[io.ComfyNode]]:
        return [DownloadWhatIWantNode]

async def comfy_entrypoint():
    return DownloadWhatIWantExtension()
